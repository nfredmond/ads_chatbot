{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["file:///C:/Code/Mike%20Strickler/ADs%20Chatbot/ai-gateway-experiment/lib/supabase/server.ts"],"sourcesContent":["import { createServerClient } from '@supabase/ssr'\r\nimport { cookies } from 'next/headers'\r\n\r\nexport async function createClient() {\r\n  const cookieStore = await cookies()\r\n\r\n  return createServerClient(\r\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\r\n    {\r\n      cookies: {\r\n        getAll() {\r\n          return cookieStore.getAll()\r\n        },\r\n        setAll(cookiesToSet) {\r\n          try {\r\n            cookiesToSet.forEach(({ name, value, options }) =>\r\n              cookieStore.set(name, value, options)\r\n            )\r\n          } catch {\r\n            // The `setAll` method was called from a Server Component.\r\n            // This can be ignored if you have middleware refreshing\r\n            // user sessions.\r\n          }\r\n        },\r\n      },\r\n    }\r\n  )\r\n}\r\n\r\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;;;AAEO,eAAe;IACpB,MAAM,cAAc,MAAM,IAAA,4IAAO;IAEjC,OAAO,IAAA,iMAAkB,sUAGvB;QACE,SAAS;YACP;gBACE,OAAO,YAAY,MAAM;YAC3B;YACA,QAAO,YAAY;gBACjB,IAAI;oBACF,aAAa,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,GAC5C,YAAY,GAAG,CAAC,MAAM,OAAO;gBAEjC,EAAE,OAAM;gBACN,0DAA0D;gBAC1D,wDAAwD;gBACxD,iBAAiB;gBACnB;YACF;QACF;IACF;AAEJ"}},
    {"offset": {"line": 150, "column": 0}, "map": {"version":3,"sources":["file:///C:/Code/Mike%20Strickler/ADs%20Chatbot/ai-gateway-experiment/lib/logging/logger.ts"],"sourcesContent":["/**\r\n * Winston Structured Logging Configuration\r\n * Provides comprehensive logging for all API operations\r\n */\r\n\r\nimport winston from 'winston'\r\nimport path from 'path'\r\n\r\n// Define log levels\r\nconst levels = {\r\n  error: 0,\r\n  warn: 1,\r\n  info: 2,\r\n  http: 3,\r\n  debug: 4,\r\n}\r\n\r\n// Define colors for each level\r\nconst colors = {\r\n  error: 'red',\r\n  warn: 'yellow',\r\n  info: 'green',\r\n  http: 'magenta',\r\n  debug: 'white',\r\n}\r\n\r\n// Tell winston about our colors\r\nwinston.addColors(colors)\r\n\r\n// Define log format\r\nconst format = winston.format.combine(\r\n  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss:ms' }),\r\n  winston.format.colorize({ all: true }),\r\n  winston.format.printf(\r\n    (info) => `${info.timestamp} ${info.level}: ${info.message}`\r\n  )\r\n)\r\n\r\n// Define log format for files (JSON)\r\nconst fileFormat = winston.format.combine(\r\n  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss:ms' }),\r\n  winston.format.json()\r\n)\r\n\r\n// Define which transports the logger must use\r\nconst transports = [\r\n  // Console transport\r\n  new winston.transports.Console({\r\n    format: format,\r\n  }),\r\n  // Error log file\r\n  new winston.transports.File({\r\n    filename: path.join(process.cwd(), 'logs', 'error.log'),\r\n    level: 'error',\r\n    format: fileFormat,\r\n  }),\r\n  // Combined log file\r\n  new winston.transports.File({\r\n    filename: path.join(process.cwd(), 'logs', 'combined.log'),\r\n    format: fileFormat,\r\n  }),\r\n  // API-specific log file\r\n  new winston.transports.File({\r\n    filename: path.join(process.cwd(), 'logs', 'api.log'),\r\n    level: 'http',\r\n    format: fileFormat,\r\n  }),\r\n]\r\n\r\n// Create the logger\r\nconst logger = winston.createLogger({\r\n  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',\r\n  levels,\r\n  transports,\r\n})\r\n\r\n/**\r\n * Custom error class for platform API errors\r\n */\r\nexport class PlatformAPIError extends Error {\r\n  platform: string\r\n  operation: string\r\n  originalError: any\r\n  timestamp: string\r\n  statusCode?: number\r\n  errorCode?: string\r\n\r\n  constructor(\r\n    platform: string,\r\n    operation: string,\r\n    originalError: any,\r\n    statusCode?: number,\r\n    errorCode?: string\r\n  ) {\r\n    super(`${platform} API error during ${operation}`)\r\n    this.platform = platform\r\n    this.operation = operation\r\n    this.originalError = originalError\r\n    this.timestamp = new Date().toISOString()\r\n    this.statusCode = statusCode\r\n    this.errorCode = errorCode\r\n    this.name = 'PlatformAPIError'\r\n\r\n    // Log the error\r\n    logger.error('Platform API Error', {\r\n      platform,\r\n      operation,\r\n      error: originalError.message || originalError,\r\n      stack: originalError.stack,\r\n      statusCode,\r\n      errorCode,\r\n      timestamp: this.timestamp,\r\n    })\r\n  }\r\n}\r\n\r\n/**\r\n * Log successful API call\r\n */\r\nexport function logAPISuccess(\r\n  platform: string,\r\n  operation: string,\r\n  details?: Record<string, any>\r\n) {\r\n  logger.http('API Success', {\r\n    platform,\r\n    operation,\r\n    timestamp: new Date().toISOString(),\r\n    ...details,\r\n  })\r\n}\r\n\r\n/**\r\n * Log OAuth flow events\r\n */\r\nexport function logOAuthEvent(\r\n  platform: string,\r\n  event: 'initiated' | 'callback' | 'success' | 'failure',\r\n  userId?: string,\r\n  error?: any\r\n) {\r\n  const level = event === 'failure' ? 'error' : 'info'\r\n  \r\n  logger.log(level, 'OAuth Event', {\r\n    platform,\r\n    event,\r\n    userId,\r\n    error: error?.message,\r\n    timestamp: new Date().toISOString(),\r\n  })\r\n}\r\n\r\n/**\r\n * Log data sync operations\r\n */\r\nexport function logSyncOperation(\r\n  platform: string,\r\n  status: 'started' | 'completed' | 'failed',\r\n  details: {\r\n    userId?: string\r\n    campaignsCount?: number\r\n    metricsCount?: number\r\n    error?: any\r\n    duration?: number\r\n  }\r\n) {\r\n  const level = status === 'failed' ? 'error' : 'info'\r\n  \r\n  logger.log(level, 'Data Sync', {\r\n    platform,\r\n    status,\r\n    timestamp: new Date().toISOString(),\r\n    ...details,\r\n  })\r\n}\r\n\r\n/**\r\n * Log token refresh operations\r\n */\r\nexport function logTokenRefresh(\r\n  platform: string,\r\n  success: boolean,\r\n  userId?: string,\r\n  error?: any\r\n) {\r\n  const level = success ? 'info' : 'error'\r\n  \r\n  logger.log(level, 'Token Refresh', {\r\n    platform,\r\n    success,\r\n    userId,\r\n    error: error?.message,\r\n    timestamp: new Date().toISOString(),\r\n  })\r\n}\r\n\r\n/**\r\n * Log rate limiting events\r\n */\r\nexport function logRateLimit(\r\n  platform: string,\r\n  rateLimitInfo: {\r\n    remaining?: number\r\n    limit?: number\r\n    resetAt?: string\r\n    throttled: boolean\r\n  }\r\n) {\r\n  logger.warn('Rate Limit Warning', {\r\n    platform,\r\n    ...rateLimitInfo,\r\n    timestamp: new Date().toISOString(),\r\n  })\r\n}\r\n\r\n/**\r\n * Log cache operations\r\n */\r\nexport function logCacheOperation(\r\n  operation: 'hit' | 'miss' | 'set' | 'delete',\r\n  key: string,\r\n  details?: Record<string, any>\r\n) {\r\n  logger.debug('Cache Operation', {\r\n    operation,\r\n    key,\r\n    timestamp: new Date().toISOString(),\r\n    ...details,\r\n  })\r\n}\r\n\r\nexport default logger\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 318, "column": 0}, "map": {"version":3,"sources":["file:///C:/Code/Mike%20Strickler/ADs%20Chatbot/ai-gateway-experiment/lib/security/encryption.ts"],"sourcesContent":["/**\r\n * Token Encryption Utilities\r\n * Uses AES-256-GCM for secure token storage\r\n */\r\n\r\nimport crypto from 'crypto'\r\n\r\nconst ALGORITHM = 'aes-256-gcm'\r\nconst IV_LENGTH = 16\r\nconst AUTH_TAG_LENGTH = 16\r\n\r\ninterface EncryptedData {\r\n  encrypted: string\r\n  iv: string\r\n  authTag: string\r\n}\r\n\r\n/**\r\n * Get encryption key from environment variable\r\n * In production, this should be stored in a secure key management service\r\n */\r\nfunction getEncryptionKey(): Buffer {\r\n  const key = process.env.ENCRYPTION_KEY\r\n  \r\n  if (!key) {\r\n    throw new Error(\r\n      'ENCRYPTION_KEY environment variable is not set. ' +\r\n      'Generate one using: openssl rand -hex 32'\r\n    )\r\n  }\r\n  \r\n  // Ensure key is 32 bytes (64 hex characters)\r\n  if (key.length !== 64) {\r\n    throw new Error('ENCRYPTION_KEY must be 64 hex characters (32 bytes)')\r\n  }\r\n  \r\n  return Buffer.from(key, 'hex')\r\n}\r\n\r\n/**\r\n * Encrypt sensitive data (tokens, secrets) before storing in database\r\n */\r\nexport function encryptToken(plaintext: string): EncryptedData {\r\n  try {\r\n    const key = getEncryptionKey()\r\n    const iv = crypto.randomBytes(IV_LENGTH)\r\n    \r\n    const cipher = crypto.createCipheriv(ALGORITHM, key, iv)\r\n    \r\n    let encrypted = cipher.update(plaintext, 'utf8', 'hex')\r\n    encrypted += cipher.final('hex')\r\n    \r\n    const authTag = cipher.getAuthTag()\r\n    \r\n    return {\r\n      encrypted: encrypted,\r\n      iv: iv.toString('hex'),\r\n      authTag: authTag.toString('hex'),\r\n    }\r\n  } catch (error) {\r\n    throw new Error(`Token encryption failed: ${error instanceof Error ? error.message : 'Unknown error'}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Decrypt sensitive data when retrieving from database\r\n */\r\nexport function decryptToken(encryptedData: EncryptedData): string {\r\n  try {\r\n    const key = getEncryptionKey()\r\n    \r\n    const decipher = crypto.createDecipheriv(\r\n      ALGORITHM,\r\n      key,\r\n      Buffer.from(encryptedData.iv, 'hex')\r\n    )\r\n    \r\n    decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'))\r\n    \r\n    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8')\r\n    decrypted += decipher.final('utf8')\r\n    \r\n    return decrypted\r\n  } catch (error) {\r\n    throw new Error(`Token decryption failed: ${error instanceof Error ? error.message : 'Unknown error'}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Generate a secure encryption key\r\n * Run this once and store the result in ENCRYPTION_KEY env variable\r\n */\r\nexport function generateEncryptionKey(): string {\r\n  return crypto.randomBytes(32).toString('hex')\r\n}\r\n\r\n/**\r\n * Encrypt multiple fields in an object\r\n */\r\nexport function encryptFields<T extends Record<string, any>>(\r\n  data: T,\r\n  fieldsToEncrypt: (keyof T)[]\r\n): Record<string, any> {\r\n  const encrypted: Record<string, any> = { ...data }\r\n  \r\n  for (const field of fieldsToEncrypt) {\r\n    const fieldStr = String(field)\r\n    const value = data[field]\r\n    if (value && typeof value === 'string') {\r\n      const encryptedData = encryptToken(value)\r\n      encrypted[`${fieldStr}_encrypted`] = encryptedData.encrypted\r\n      encrypted[`${fieldStr}_iv`] = encryptedData.iv\r\n      encrypted[`${fieldStr}_auth_tag`] = encryptedData.authTag\r\n      delete encrypted[fieldStr]\r\n    }\r\n  }\r\n  \r\n  return encrypted\r\n}\r\n\r\n/**\r\n * Decrypt multiple fields in an object\r\n */\r\nexport function decryptFields<T extends Record<string, any>>(\r\n  data: T,\r\n  fieldsToDecrypt: string[]\r\n): Record<string, any> {\r\n  const decrypted: Record<string, any> = { ...data }\r\n  \r\n  for (const field of fieldsToDecrypt) {\r\n    const encryptedField = `${field}_encrypted`\r\n    const ivField = `${field}_iv`\r\n    const authTagField = `${field}_auth_tag`\r\n    \r\n    if (data[encryptedField] && data[ivField] && data[authTagField]) {\r\n      try {\r\n        const encryptedData: EncryptedData = {\r\n          encrypted: data[encryptedField] as string,\r\n          iv: data[ivField] as string,\r\n          authTag: data[authTagField] as string,\r\n        }\r\n        \r\n        decrypted[field] = decryptToken(encryptedData)\r\n        delete decrypted[encryptedField]\r\n        delete decrypted[ivField]\r\n        delete decrypted[authTagField]\r\n      } catch (error) {\r\n        console.error(`Failed to decrypt field ${field}:`, error)\r\n        // Keep encrypted fields if decryption fails\r\n      }\r\n    }\r\n  }\r\n  \r\n  return decrypted\r\n}\r\n\r\n/**\r\n * Utility to test encryption/decryption\r\n */\r\nexport function testEncryption(): boolean {\r\n  try {\r\n    const testData = 'test-token-12345'\r\n    const encrypted = encryptToken(testData)\r\n    const decrypted = decryptToken(encrypted)\r\n    \r\n    return decrypted === testData\r\n  } catch (error) {\r\n    console.error('Encryption test failed:', error)\r\n    return false\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 445, "column": 0}, "map": {"version":3,"sources":["file:///C:/Code/Mike%20Strickler/ADs%20Chatbot/ai-gateway-experiment/lib/supabase/service-role.ts"],"sourcesContent":["import { createClient, SupabaseClient } from '@supabase/supabase-js'\n\n/**\n * Creates a Supabase client with service role privileges.\n * This client bypasses Row Level Security and should only be used\n * for server-side operations that need elevated permissions.\n * \n * @throws Error if environment variables are not set at runtime\n */\nexport function createServiceRoleClient(): SupabaseClient {\n  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL\n  const supabaseServiceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY\n\n  if (!supabaseUrl) {\n    throw new Error(\n      'NEXT_PUBLIC_SUPABASE_URL environment variable is not set. ' +\n      'Please add it to your .env.local file.'\n    )\n  }\n\n  if (!supabaseServiceRoleKey) {\n    throw new Error(\n      'SUPABASE_SERVICE_ROLE_KEY environment variable is not set. ' +\n      'Please add it to your .env.local file.'\n    )\n  }\n\n  return createClient(supabaseUrl, supabaseServiceRoleKey, {\n    auth: {\n      persistSession: false,\n    },\n  })\n}\n"],"names":[],"mappings":";;;;AAAA;;AASO,SAAS;IACd,MAAM;IACN,MAAM,yBAAyB,QAAQ,GAAG,CAAC,yBAAyB;IAEpE;;IAOA,IAAI,CAAC,wBAAwB;QAC3B,MAAM,IAAI,MACR,gEACA;IAEJ;IAEA,OAAO,IAAA,yMAAY,EAAC,aAAa,wBAAwB;QACvD,MAAM;YACJ,gBAAgB;QAClB;IACF;AACF"}},
    {"offset": {"line": 469, "column": 0}, "map": {"version":3,"sources":["file:///C:/Code/Mike%20Strickler/ADs%20Chatbot/ai-gateway-experiment/lib/security/ad-account-tokens.ts"],"sourcesContent":["import logger from '../logging/logger'\r\nimport { encryptToken, decryptToken } from './encryption'\r\nimport { createServiceRoleClient } from '../supabase/service-role'\r\n\r\ninterface TokenUpdateInput {\r\n  accessToken?: string | null\r\n  refreshToken?: string | null\r\n}\r\n\r\ninterface DecryptedTokens {\r\n  accessToken: string | null\r\n  refreshToken: string | null\r\n}\r\n\r\nfunction buildEncryptedFields(token?: string | null) {\r\n  if (!token) {\r\n    return null\r\n  }\r\n\r\n  const encrypted = encryptToken(token)\r\n\r\n  return {\r\n    encrypted: encrypted.encrypted,\r\n    iv: encrypted.iv,\r\n    authTag: encrypted.authTag,\r\n  }\r\n}\r\n\r\nexport function buildEncryptedTokenUpdate(tokens: TokenUpdateInput) {\r\n  const update: Record<string, any> = {}\r\n\r\n  const access = buildEncryptedFields(tokens.accessToken)\r\n  if (access) {\r\n    update.access_token_encrypted = access.encrypted\r\n    update.access_token_iv = access.iv\r\n    update.access_token_auth_tag = access.authTag\r\n    update.access_token = null\r\n  }\r\n\r\n  const refresh = buildEncryptedFields(tokens.refreshToken)\r\n  if (refresh) {\r\n    update.refresh_token_encrypted = refresh.encrypted\r\n    update.refresh_token_iv = refresh.iv\r\n    update.refresh_token_auth_tag = refresh.authTag\r\n    update.refresh_token = null\r\n  }\r\n\r\n  return update\r\n}\r\n\r\nexport function decryptAccountTokens(account: any): DecryptedTokens {\r\n  let accessToken: string | null = null\r\n  let refreshToken: string | null = null\r\n\r\n  if (\r\n    account?.access_token_encrypted &&\r\n    account?.access_token_iv &&\r\n    account?.access_token_auth_tag\r\n  ) {\r\n    try {\r\n      accessToken = decryptToken({\r\n        encrypted: account.access_token_encrypted,\r\n        iv: account.access_token_iv,\r\n        authTag: account.access_token_auth_tag,\r\n      })\r\n    } catch (error) {\r\n      logger.error('Failed to decrypt access token', {\r\n        accountId: account?.id,\r\n        platform: account?.platform,\r\n        error,\r\n      })\r\n    }\r\n  } else if (account?.access_token) {\r\n    accessToken = account.access_token\r\n  }\r\n\r\n  if (\r\n    account?.refresh_token_encrypted &&\r\n    account?.refresh_token_iv &&\r\n    account?.refresh_token_auth_tag\r\n  ) {\r\n    try {\r\n      refreshToken = decryptToken({\r\n        encrypted: account.refresh_token_encrypted,\r\n        iv: account.refresh_token_iv,\r\n        authTag: account.refresh_token_auth_tag,\r\n      })\r\n    } catch (error) {\r\n      logger.error('Failed to decrypt refresh token', {\r\n        accountId: account?.id,\r\n        platform: account?.platform,\r\n        error,\r\n      })\r\n    }\r\n  } else if (account?.refresh_token) {\r\n    refreshToken = account.refresh_token\r\n  }\r\n\r\n  return { accessToken, refreshToken }\r\n}\r\n\r\nexport async function migratePlaintextTokens() {\r\n  try {\r\n    const supabase = createServiceRoleClient()\r\n\r\n    const { data: accounts, error } = await supabase\r\n      .from('ad_accounts')\r\n      .select(\r\n        'id, platform, access_token, refresh_token, access_token_encrypted, refresh_token_encrypted'\r\n      )\r\n      .or('access_token.not.is.null,refresh_token.not.is.null')\r\n\r\n    if (error) {\r\n      logger.error('Failed to query ad accounts for token migration', { error })\r\n      return\r\n    }\r\n\r\n    if (!accounts || accounts.length === 0) {\r\n      logger.info('No plaintext tokens found to migrate')\r\n      return\r\n    }\r\n\r\n    logger.info('Migrating plaintext ad account tokens', {\r\n      accounts: accounts.length,\r\n    })\r\n\r\n    for (const account of accounts) {\r\n      const update = buildEncryptedTokenUpdate({\r\n        accessToken: account.access_token,\r\n        refreshToken: account.refresh_token,\r\n      })\r\n\r\n      if (Object.keys(update).length === 0) {\r\n        continue\r\n      }\r\n\r\n      update.updated_at = new Date().toISOString()\r\n\r\n      const { error: updateError } = await supabase\r\n        .from('ad_accounts')\r\n        .update(update)\r\n        .eq('id', account.id)\r\n\r\n      if (updateError) {\r\n        logger.error('Failed to migrate tokens for ad account', {\r\n          accountId: account.id,\r\n          platform: account.platform,\r\n          error: updateError,\r\n        })\r\n      }\r\n    }\r\n\r\n    logger.info('Plaintext token migration completed')\r\n  } catch (error) {\r\n    logger.error('Token migration failed', { error })\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 600, "column": 0}, "map": {"version":3,"sources":["file:///C:/Code/Mike%20Strickler/ADs%20Chatbot/ai-gateway-experiment/app/auth/google/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\r\nimport { createClient } from '@/lib/supabase/server'\r\nimport crypto from 'crypto'\r\nimport logger, { logOAuthEvent } from '@/lib/logging/logger'\r\nimport { buildEncryptedTokenUpdate } from '@/lib/security/ad-account-tokens'\r\n\r\nconst GOOGLE_OAUTH_URL = 'https://accounts.google.com/o/oauth2/v2/auth'\r\nconst GOOGLE_TOKEN_URL = 'https://oauth2.googleapis.com/token'\r\n\r\nexport async function GET(request: NextRequest) {\r\n  let user: any = null\r\n  \r\n  const supabase = await createClient()\r\n  const searchParams = request.nextUrl.searchParams\r\n  const code = searchParams.get('code')\r\n  const state = searchParams.get('state')\r\n  const error = searchParams.get('error')\r\n\r\n  // Handle OAuth errors\r\n  if (error) {\r\n    return NextResponse.redirect(\r\n      new URL(`/dashboard/settings?error=${encodeURIComponent(error)}`, request.url)\r\n    )\r\n  }\r\n\r\n  // Initiating OAuth flow\r\n  if (!code) {\r\n    const authResponse = await supabase.auth.getUser()\r\n    user = authResponse.data.user\r\n    \r\n    if (!user) {\r\n      return NextResponse.redirect(new URL('/login', request.url))\r\n    }\r\n\r\n    logOAuthEvent('google_ads', 'initiated', user.id)\r\n\r\n    // Get profile with tenant_id\r\n    const { data: profile } = await supabase\r\n      .from('profiles')\r\n      .select('tenant_id')\r\n      .eq('id', user.id)\r\n      .single()\r\n\r\n    if (!profile?.tenant_id) {\r\n      return NextResponse.redirect(\r\n        new URL('/dashboard/settings?error=No tenant found', request.url)\r\n      )\r\n    }\r\n\r\n    // Get Google Ads credentials from ad_accounts\r\n    const { data: adAccount } = await supabase\r\n      .from('ad_accounts')\r\n      .select('metadata')\r\n      .eq('tenant_id', profile.tenant_id)\r\n      .eq('platform', 'google_ads')\r\n      .single()\r\n\r\n    if (!adAccount?.metadata?.client_id || !adAccount?.metadata?.client_secret) {\r\n      return NextResponse.redirect(\r\n        new URL('/dashboard/settings?error=Google Ads credentials not configured', request.url)\r\n      )\r\n    }\r\n\r\n    // Generate state for CSRF protection\r\n    const stateToken = crypto.randomBytes(32).toString('hex')\r\n\r\n    // Store state in session (using cookies for simplicity)\r\n    const response = NextResponse.redirect(\r\n      new URL(\r\n        `${GOOGLE_OAUTH_URL}?` +\r\n          new URLSearchParams({\r\n            client_id: adAccount.metadata.client_id,\r\n            redirect_uri: `${request.nextUrl.origin}/auth/google`,\r\n            response_type: 'code',\r\n            scope: 'https://www.googleapis.com/auth/adwords',\r\n            access_type: 'offline',\r\n            include_granted_scopes: 'true',\r\n            state: stateToken,\r\n            prompt: 'consent', // Force consent to get refresh token\r\n          }).toString(),\r\n        request.url\r\n      )\r\n    )\r\n\r\n    response.cookies.set('google_oauth_state', stateToken, {\r\n      httpOnly: true,\r\n      secure: process.env.NODE_ENV === 'production',\r\n      sameSite: 'lax',\r\n      maxAge: 600, // 10 minutes\r\n    })\r\n\r\n    return response\r\n  }\r\n\r\n  // Handle OAuth callback\r\n  try {\r\n    const storedState = request.cookies.get('google_oauth_state')?.value\r\n\r\n    if (!state || state !== storedState) {\r\n      throw new Error('Invalid state parameter - possible CSRF attack')\r\n    }\r\n\r\n    const authResponse = await supabase.auth.getUser()\r\n    user = authResponse.data.user\r\n    \r\n    if (!user) {\r\n      return NextResponse.redirect(new URL('/login', request.url))\r\n    }\r\n\r\n    const { data: profile } = await supabase\r\n      .from('profiles')\r\n      .select('tenant_id')\r\n      .eq('id', user.id)\r\n      .single()\r\n\r\n    if (!profile?.tenant_id) {\r\n      throw new Error('No tenant found')\r\n    }\r\n\r\n    // Get credentials again - query by (tenant_id, platform) to find the account\r\n    // This ensures we update the same account even if credentials were changed\r\n    const { data: adAccount } = await supabase\r\n      .from('ad_accounts')\r\n      .select('id, metadata, account_id')\r\n      .eq('tenant_id', profile.tenant_id)\r\n      .eq('platform', 'google_ads')\r\n      .maybeSingle()\r\n\r\n    if (!adAccount) {\r\n      throw new Error('Google Ads account not found. Please configure credentials in Settings first.')\r\n    }\r\n\r\n    // Exchange code for tokens\r\n    const tokenResponse = await fetch(GOOGLE_TOKEN_URL, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/x-www-form-urlencoded',\r\n      },\r\n      body: new URLSearchParams({\r\n        client_id: adAccount.metadata.client_id,\r\n        client_secret: adAccount.metadata.client_secret,\r\n        code: code,\r\n        grant_type: 'authorization_code',\r\n        redirect_uri: `${request.nextUrl.origin}/auth/google`,\r\n      }),\r\n    })\r\n\r\n    if (!tokenResponse.ok) {\r\n      const error = await tokenResponse.json()\r\n      throw new Error(error.error_description || 'Failed to exchange code for tokens')\r\n    }\r\n\r\n    const tokens = await tokenResponse.json()\r\n\r\n    if (!tokens.refresh_token) {\r\n      throw new Error('No refresh token received. Please revoke access and try again.')\r\n    }\r\n\r\n    const tokenUpdate = buildEncryptedTokenUpdate({\r\n      accessToken: tokens.access_token,\r\n      refreshToken: tokens.refresh_token,\r\n    })\r\n\r\n    // Update ad_accounts with refresh token\r\n    // Note: We update by (tenant_id, platform) to ensure we always update the correct record\r\n    const { error: updateError } = await supabase\r\n      .from('ad_accounts')\r\n      .update({\r\n        ...tokenUpdate,\r\n        token_expires_at: new Date(Date.now() + tokens.expires_in * 1000).toISOString(),\r\n        status: 'active',\r\n        last_synced_at: null, // Reset sync time\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .eq('tenant_id', profile.tenant_id)\r\n      .eq('platform', 'google_ads')\r\n\r\n    if (updateError) throw updateError\r\n\r\n    logOAuthEvent('google_ads', 'success', user.id)\r\n\r\n    // Clear state cookie\r\n    const response = NextResponse.redirect(\r\n      new URL('/dashboard/settings?success=Google Ads connected successfully', request.url)\r\n    )\r\n    response.cookies.delete('google_oauth_state')\r\n\r\n    return response\r\n  } catch (error: any) {\r\n    logger.error('Google OAuth error:', error)\r\n    logOAuthEvent('google_ads', 'failure', user?.id, error)\r\n    \r\n    const response = NextResponse.redirect(\r\n      new URL(`/dashboard/settings?error=${encodeURIComponent(error.message)}`, request.url)\r\n    )\r\n    response.cookies.delete('google_oauth_state')\r\n    return response\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"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"}}]
}