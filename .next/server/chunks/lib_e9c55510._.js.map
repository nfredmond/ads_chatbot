{"version":3,"sources":["../../../lib/meta-ads/app-secret-proof.ts","../../../lib/meta-ads/client.ts"],"sourcesContent":["/**\r\n * Meta Ads App Secret Proof Generator\r\n * Provides additional security for API calls\r\n */\r\n\r\nimport crypto from 'crypto'\r\n\r\n/**\r\n * Generate App Secret Proof for Meta API calls\r\n * This adds an extra layer of security by proving you have the app secret\r\n * \r\n * @param accessToken - The access token being used\r\n * @param appSecret - Your app's secret key\r\n * @returns The app secret proof (HMAC-SHA256 hash)\r\n */\r\nexport function generateAppsecretProof(accessToken: string, appSecret: string): string {\r\n  if (!accessToken || !appSecret) {\r\n    throw new Error('Access token and app secret are required to generate app secret proof')\r\n  }\r\n\r\n  return crypto\r\n    .createHmac('sha256', appSecret)\r\n    .update(accessToken)\r\n    .digest('hex')\r\n}\r\n\r\n/**\r\n * Add App Secret Proof to Meta API request headers\r\n */\r\nexport function addAppsecretProofToHeaders(\r\n  headers: Record<string, string>,\r\n  accessToken: string,\r\n  appSecret: string\r\n): Record<string, string> {\r\n  const appsecretProof = generateAppsecretProof(accessToken, appSecret)\r\n\r\n  return {\r\n    ...headers,\r\n    'appsecret_proof': appsecretProof,\r\n  }\r\n}\r\n\r\n/**\r\n * Add App Secret Proof to Meta API request URL params\r\n */\r\nexport function addAppsecretProofToParams(\r\n  params: URLSearchParams,\r\n  accessToken: string,\r\n  appSecret: string\r\n): URLSearchParams {\r\n  const appsecretProof = generateAppsecretProof(accessToken, appSecret)\r\n  params.set('appsecret_proof', appsecretProof)\r\n  return params\r\n}\r\n\r\n/**\r\n * Verify App Secret Proof (for webhooks)\r\n */\r\nexport function verifyAppsecretProof(\r\n  accessToken: string,\r\n  appSecret: string,\r\n  providedProof: string\r\n): boolean {\r\n  const expectedProof = generateAppsecretProof(accessToken, appSecret)\r\n  return crypto.timingSafeEqual(\r\n    Buffer.from(expectedProof, 'utf8'),\r\n    Buffer.from(providedProof, 'utf8')\r\n  )\r\n}\r\n\r\n","/**\r\n * Meta Ads (Facebook) API Client\r\n * Documentation: https://developers.facebook.com/docs/marketing-api/insights\r\n */\r\n\r\nimport { generateAppsecretProof } from './app-secret-proof'\r\nimport logger, { PlatformAPIError, logAPISuccess } from '../logging/logger'\r\nimport { withRateLimit } from '../rate-limiting/limiter'\r\n\r\nconst DEFAULT_GRAPH_VERSION = 'v21.0'\r\n\r\nexport interface MetaAdsConfig {\r\n  accessToken: string\r\n  accountId: string\r\n  apiVersion?: string\r\n  appSecret?: string // For App Secret Proof\r\n}\r\n\r\ninterface MetaPagingResponse<T> {\r\n  data: T[]\r\n  paging?: {\r\n    next?: string\r\n  }\r\n}\r\n\r\nasync function fetchAllPages<T>(initialUrl: string): Promise<T[]> {\r\n  const results: T[] = []\r\n  let nextUrl: string | undefined = initialUrl\r\n\r\n  while (nextUrl) {\r\n    try {\r\n      const response = await fetch(nextUrl, {\r\n        method: 'GET',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n      })\r\n\r\n      // Check rate limit headers\r\n      const rateLimiter = (await import('../rate-limiting/limiter')).default()\r\n      rateLimiter.checkMetaRateLimit(Object.fromEntries(response.headers.entries()))\r\n\r\n      if (!response.ok) {\r\n        const errorText = await response.text()\r\n        let error: any = {}\r\n        try {\r\n          error = JSON.parse(errorText)\r\n        } catch {\r\n          error = { error: { message: errorText || response.statusText } }\r\n        }\r\n\r\n        // Handle specific Meta API errors\r\n        const errorCode = error.error?.code\r\n        const errorMessage = error.error?.message || response.statusText\r\n\r\n        // Token expiration or invalid token\r\n        if (errorCode === 190 || response.status === 401) {\r\n          throw new PlatformAPIError(\r\n            'meta_ads',\r\n            'fetchAllPages',\r\n            new Error('Access token expired or invalid. Please reconnect your Meta Ads account.'),\r\n            response.status,\r\n            errorCode?.toString()\r\n          )\r\n        }\r\n\r\n        // Rate limit errors\r\n        if ([4, 17, 32, 613].includes(errorCode)) {\r\n          throw new PlatformAPIError(\r\n            'meta_ads',\r\n            'fetchAllPages',\r\n            new Error(`Rate limit exceeded: ${errorMessage}`),\r\n            response.status,\r\n            errorCode?.toString()\r\n          )\r\n        }\r\n\r\n        throw new PlatformAPIError(\r\n          'meta_ads',\r\n          'fetchAllPages',\r\n          new Error(errorMessage),\r\n          response.status,\r\n          errorCode?.toString()\r\n        )\r\n      }\r\n\r\n      const body = (await response.json()) as MetaPagingResponse<T>\r\n      if (Array.isArray(body.data)) {\r\n        results.push(...body.data)\r\n      }\r\n\r\n      nextUrl = body.paging?.next\r\n    } catch (error: any) {\r\n      // Re-throw PlatformAPIError as-is\r\n      if (error instanceof PlatformAPIError) {\r\n        throw error\r\n      }\r\n      // Wrap other errors\r\n      throw new PlatformAPIError(\r\n        'meta_ads',\r\n        'fetchAllPages',\r\n        error,\r\n        undefined,\r\n        undefined\r\n      )\r\n    }\r\n  }\r\n\r\n  return results\r\n}\r\n\r\nexport async function fetchMetaAdsCampaigns(config: MetaAdsConfig) {\r\n  const apiVersion = config.apiVersion ?? DEFAULT_GRAPH_VERSION\r\n  \r\n  // Ensure account ID has act_ prefix\r\n  let accountId = config.accountId\r\n  if (!accountId.startsWith('act_')) {\r\n    // Remove any existing act_ prefix and add it\r\n    accountId = accountId.replace(/^act_/, '')\r\n    accountId = `act_${accountId}`\r\n  }\r\n\r\n  const since = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]\r\n  const until = new Date().toISOString().split('T')[0]\r\n\r\n  logger.info('Fetching Meta Ads campaigns', { accountId, dateRange: { since, until } })\r\n\r\n  // Validate required configuration\r\n  if (!config.accessToken) {\r\n    throw new Error('Meta Ads access token is required')\r\n  }\r\n  if (!accountId) {\r\n    throw new Error('Meta Ads account ID is required')\r\n  }\r\n\r\n  // Fetch campaign metadata (name, status, budget)\r\n  const campaignsParams = new URLSearchParams({\r\n    fields: 'id,name,status,daily_budget,objective',\r\n    access_token: config.accessToken,\r\n    limit: '100',\r\n  })\r\n\r\n  // Add App Secret Proof if available for enhanced security\r\n  if (config.appSecret) {\r\n    const appsecretProof = generateAppsecretProof(config.accessToken, config.appSecret)\r\n    campaignsParams.set('appsecret_proof', appsecretProof)\r\n  }\r\n\r\n  const campaignsUrl = `https://graph.facebook.com/${apiVersion}/${accountId}/campaigns?${campaignsParams.toString()}`\r\n  \r\n  const campaignMetadata = await withRateLimit('meta_ads', async () => {\r\n    return await fetchAllPages<{\r\n      id: string\r\n      name: string\r\n      status: string\r\n      daily_budget?: string\r\n      objective?: string\r\n    }>(campaignsUrl)\r\n  })\r\n\r\n  // Fetch insights at campaign level as recommended by Meta\r\n  const insightsParams = new URLSearchParams({\r\n    fields:\r\n      'campaign_id,campaign_name,campaign_status,objective,impressions,clicks,spend,actions,action_values,date_start,date_stop',\r\n    level: 'campaign',\r\n    time_range: JSON.stringify({ since, until }),\r\n    action_attribution_windows: JSON.stringify(['1d_click', '7d_click']),\r\n    use_unified_attribution_setting: 'true',\r\n    access_token: config.accessToken,\r\n    limit: '100',\r\n  })\r\n\r\n  // Add App Secret Proof for enhanced security\r\n  if (config.appSecret) {\r\n    const appsecretProof = generateAppsecretProof(config.accessToken, config.appSecret)\r\n    insightsParams.set('appsecret_proof', appsecretProof)\r\n  }\r\n\r\n  const insightsUrl = `https://graph.facebook.com/${apiVersion}/${accountId}/insights?${insightsParams.toString()}`\r\n  \r\n  const insightsData = await withRateLimit('meta_ads', async () => {\r\n    return await fetchAllPages<{\r\n      campaign_id: string\r\n      campaign_name: string\r\n      campaign_status: string\r\n      objective?: string\r\n      impressions?: string\r\n      clicks?: string\r\n      spend?: string\r\n      actions?: Array<{ action_type: string; value: string }>\r\n      action_values?: Array<{ action_type: string; value: string }>\r\n      date_start?: string\r\n      date_stop?: string\r\n    }>(insightsUrl)\r\n  })\r\n\r\n  logAPISuccess('meta_ads', 'fetchCampaigns', {\r\n    campaignCount: campaignMetadata.length,\r\n    insightsCount: insightsData.length,\r\n  })\r\n\r\n  return { campaignMetadata, insightsData, dateRange: { since, until } }\r\n}\r\n\r\nexport function transformMetaAdsData(apiData: {\r\n  campaignMetadata: Array<{\r\n    id: string\r\n    name: string\r\n    status: string\r\n    daily_budget?: string\r\n    objective?: string\r\n  }>\r\n  insightsData: Array<{\r\n    campaign_id: string\r\n    campaign_name: string\r\n    campaign_status: string\r\n    objective?: string\r\n    impressions?: string\r\n    clicks?: string\r\n    spend?: string\r\n    actions?: Array<{ action_type: string; value: string }>\r\n    action_values?: Array<{ action_type: string; value: string }>\r\n    date_start?: string\r\n    date_stop?: string\r\n  }>\r\n  dateRange: { since: string; until: string }\r\n}) {\r\n  const campaigns: any[] = []\r\n  const metrics: any[] = []\r\n\r\n  const metadataById = new Map(\r\n    apiData.campaignMetadata.map((campaign) => [campaign.id, campaign])\r\n  )\r\n\r\n  const seenCampaigns = new Set<string>()\r\n\r\n  apiData.insightsData.forEach((insight) => {\r\n    if (!seenCampaigns.has(insight.campaign_id)) {\r\n      const meta = metadataById.get(insight.campaign_id)\r\n\r\n      campaigns.push({\r\n        campaign_id: insight.campaign_id,\r\n        campaign_name: insight.campaign_name,\r\n        platform: 'meta_ads',\r\n        status: normalizeMetaStatus(insight.campaign_status || meta?.status || 'UNKNOWN'),\r\n        budget_amount: meta?.daily_budget ? parseFloat(meta.daily_budget) / 100 : null,\r\n        objective: insight.objective || meta?.objective || null,\r\n      })\r\n\r\n      seenCampaigns.add(insight.campaign_id)\r\n    }\r\n\r\n    const purchaseAction = insight.actions?.find(\r\n      (action) => action.action_type === 'offsite_conversion.fb_pixel_purchase' || \r\n                 action.action_type === 'purchase'\r\n    )\r\n    const revenueAction = insight.action_values?.find(\r\n      (action) => action.action_type === 'offsite_conversion.fb_pixel_purchase' ||\r\n                 action.action_type === 'purchase'\r\n    )\r\n\r\n    metrics.push({\r\n      campaign_api_id: insight.campaign_id,\r\n      date: insight.date_stop || apiData.dateRange.until,\r\n      impressions: insight.impressions ? parseInt(insight.impressions, 10) : 0,\r\n      clicks: insight.clicks ? parseInt(insight.clicks, 10) : 0,\r\n      conversions: purchaseAction ? parseFloat(purchaseAction.value) : 0,\r\n      spend: insight.spend ? parseFloat(insight.spend) : 0,\r\n      revenue: revenueAction ? parseFloat(revenueAction.value) : 0,\r\n    })\r\n  })\r\n\r\n  return { campaigns, metrics }\r\n}\r\n\r\nfunction normalizeMetaStatus(status: string): string {\r\n  const statusMap: Record<string, string> = {\r\n    'ACTIVE': 'active',\r\n    'PAUSED': 'paused',\r\n    'DELETED': 'archived',\r\n    'ARCHIVED': 'archived',\r\n  }\r\n  return statusMap[status] || status.toLowerCase()\r\n}\r\n\r\n"],"names":[],"mappings":"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"}