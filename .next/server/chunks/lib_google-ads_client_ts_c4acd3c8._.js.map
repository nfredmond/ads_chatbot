{"version":3,"sources":["../../../lib/google-ads/client.ts"],"sourcesContent":["/**\r\n * Google Ads API Client\r\n * Documentation:\r\n * - Getting started: https://developers.google.com/google-ads/api/docs/get-started/make-first-call\r\n * - OAuth: https://developers.google.com/google-ads/api/docs/oauth/overview\r\n * - Common errors: https://developers.google.com/google-ads/api/docs/get-started/common-errors\r\n */\r\n\r\nimport logger, { PlatformAPIError, logAPISuccess, logTokenRefresh } from '../logging/logger'\r\nimport { withRateLimit } from '../rate-limiting/limiter'\r\n\r\nexport interface GoogleAdsConfig {\r\n  clientId: string\r\n  clientSecret: string\r\n  developerToken: string\r\n  customerId: string\r\n  refreshToken?: string\r\n  loginCustomerId?: string\r\n}\r\n\r\nexport async function getGoogleAdsAccessToken(\r\n  clientId: string,\r\n  clientSecret: string,\r\n  refreshToken: string\r\n): Promise<string> {\r\n  try {\r\n    const response = await fetch('https://oauth2.googleapis.com/token', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/x-www-form-urlencoded',\r\n      },\r\n      body: new URLSearchParams({\r\n        client_id: clientId,\r\n        client_secret: clientSecret,\r\n        refresh_token: refreshToken,\r\n        grant_type: 'refresh_token',\r\n      }),\r\n    })\r\n\r\n    const data = await response.json()\r\n\r\n    if (!response.ok) {\r\n      const errorMessage = data.error_description || data.error || 'Failed to refresh access token'\r\n      logTokenRefresh('google_ads', false, undefined, new Error(errorMessage))\r\n      throw new PlatformAPIError('google_ads', 'refreshToken', new Error(errorMessage), response.status, data.error)\r\n    }\r\n\r\n    if (!data.access_token) {\r\n      const error = new Error('No access token returned from Google OAuth refresh flow')\r\n      logTokenRefresh('google_ads', false, undefined, error)\r\n      throw error\r\n    }\r\n\r\n    logTokenRefresh('google_ads', true)\r\n    return data.access_token\r\n  } catch (error) {\r\n    throw error\r\n  }\r\n}\r\n\r\n/**\r\n * List accessible customer accounts (for manager accounts)\r\n */\r\nasync function listAccessibleCustomers(\r\n  accessToken: string,\r\n  developerToken: string\r\n): Promise<string[]> {\r\n  const endpoint = 'https://googleads.googleapis.com/v21/customers:listAccessibleCustomers'\r\n  \r\n  const response = await fetch(endpoint, {\r\n    method: 'GET',\r\n    headers: {\r\n      'Content-Type': 'application/json',\r\n      Authorization: `Bearer ${accessToken}`,\r\n      'developer-token': developerToken,\r\n    },\r\n  })\r\n\r\n  const data = await response.json()\r\n\r\n  if (!response.ok) {\r\n    console.error('Failed to list accessible customers:', JSON.stringify(data, null, 2))\r\n    return []\r\n  }\r\n\r\n  // Extract customer IDs from resource names like \"customers/1234567890\"\r\n  const customerIds = (data.resourceNames || []).map((name: string) => \r\n    name.replace('customers/', '')\r\n  )\r\n  \r\n  logger.info('Found accessible customer accounts', { count: customerIds.length, customerIds })\r\n  return customerIds\r\n}\r\n\r\nexport interface ClientAccount {\r\n  id: string\r\n  name: string\r\n}\r\n\r\n/**\r\n * List client accounts under a manager account using CustomerClient resource\r\n */\r\nasync function listClientAccounts(\r\n  managerCustomerId: string,\r\n  accessToken: string,\r\n  developerToken: string\r\n): Promise<ClientAccount[]> {\r\n  const query = `\r\n    SELECT \r\n      customer_client.client_customer,\r\n      customer_client.level,\r\n      customer_client.manager,\r\n      customer_client.status,\r\n      customer_client.descriptive_name\r\n    FROM customer_client\r\n    WHERE customer_client.level = 1\r\n      AND customer_client.status = 'ENABLED'\r\n  `\r\n  \r\n  const endpoint = `https://googleads.googleapis.com/v21/customers/${managerCustomerId}/googleAds:search`\r\n  \r\n  const response = await fetch(endpoint, {\r\n    method: 'POST',\r\n    headers: {\r\n      'Content-Type': 'application/json',\r\n      Authorization: `Bearer ${accessToken}`,\r\n      'developer-token': developerToken,\r\n      'login-customer-id': managerCustomerId,\r\n    },\r\n    body: JSON.stringify({ query }),\r\n  })\r\n\r\n  const data = await response.json()\r\n\r\n  if (!response.ok) {\r\n    console.error('Failed to list client accounts:', JSON.stringify(data, null, 2))\r\n    return []\r\n  }\r\n\r\n  const clients: ClientAccount[] = []\r\n  const rows = data.results || []\r\n  \r\n  for (const row of rows) {\r\n    const clientCustomer = row?.customerClient?.clientCustomer\r\n    const isManager = row?.customerClient?.manager === true\r\n    const name = row?.customerClient?.descriptiveName || 'Unknown'\r\n    \r\n    if (clientCustomer && !isManager) {\r\n      // Extract customer ID from resource name like \"customers/1234567890\"\r\n      const clientId = clientCustomer.replace('customers/', '')\r\n      clients.push({ id: clientId, name })\r\n      logger.info(`Found client account: ${name} (${clientId})`)\r\n    }\r\n  }\r\n  \r\n  logger.info('Found client accounts under manager', { count: clients.length })\r\n  return clients\r\n}\r\n\r\n/**\r\n * Check if a customer ID is a manager account\r\n */\r\nasync function isManagerAccount(\r\n  customerId: string,\r\n  accessToken: string,\r\n  developerToken: string,\r\n  loginCustomerId?: string\r\n): Promise<boolean> {\r\n  const query = `SELECT customer.manager FROM customer WHERE customer.id = ${customerId}`\r\n  const endpoint = `https://googleads.googleapis.com/v21/customers/${customerId}/googleAds:search`\r\n  \r\n  try {\r\n    const response = await fetch(endpoint, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        Authorization: `Bearer ${accessToken}`,\r\n        'developer-token': developerToken,\r\n        ...(loginCustomerId ? { 'login-customer-id': loginCustomerId } : {}),\r\n      },\r\n      body: JSON.stringify({ query }),\r\n    })\r\n\r\n    const data = await response.json()\r\n    \r\n    if (!response.ok) {\r\n      return false\r\n    }\r\n\r\n    const isManager = data.results?.[0]?.customer?.manager === true\r\n    return isManager\r\n  } catch {\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * Fetch campaigns from a single customer account\r\n */\r\nasync function fetchCampaignsFromCustomer(\r\n  customerId: string,\r\n  accessToken: string,\r\n  developerToken: string,\r\n  loginCustomerId?: string\r\n): Promise<any> {\r\n  const query = `\r\n    SELECT\r\n      campaign.id,\r\n      campaign.name,\r\n      campaign.status,\r\n      campaign_budget.amount_micros,\r\n      metrics.impressions,\r\n      metrics.clicks,\r\n      metrics.conversions,\r\n      metrics.conversions_value,\r\n      metrics.cost_micros,\r\n      metrics.ctr,\r\n      metrics.average_cpc,\r\n      segments.date\r\n    FROM campaign\r\n    WHERE segments.date DURING LAST_30_DAYS\r\n    ORDER BY metrics.clicks DESC\r\n  `\r\n\r\n  const endpoint = `https://googleads.googleapis.com/v21/customers/${customerId}/googleAds:search`\r\n\r\n  const response = await fetch(endpoint, {\r\n    method: 'POST',\r\n    headers: {\r\n      'Content-Type': 'application/json',\r\n      Authorization: `Bearer ${accessToken}`,\r\n      'developer-token': developerToken,\r\n      ...(loginCustomerId ? { 'login-customer-id': loginCustomerId } : {}),\r\n    },\r\n    body: JSON.stringify({ query }),\r\n  })\r\n\r\n  const responseData = await response.json()\r\n\r\n  if (!response.ok) {\r\n    const errorDetails = responseData.error?.details?.[0]?.errors?.[0] || responseData.error\r\n    const errorMessage = errorDetails?.message || responseData.error?.message || 'Unknown error'\r\n    const errorCode = errorDetails?.errorCode\r\n    \r\n    // If this is a manager account error, return empty results (we'll handle it in the parent)\r\n    if (errorCode?.queryError === 'REQUESTED_METRICS_FOR_MANAGER') {\r\n      logger.info(`Skipping manager account ${customerId}`)\r\n      return { results: [], isManager: true }\r\n    }\r\n    \r\n    console.error(`Error fetching from customer ${customerId}:`, errorMessage)\r\n    return { results: [], error: errorMessage }\r\n  }\r\n\r\n  return responseData\r\n}\r\n\r\nexport async function fetchGoogleAdsCampaigns(config: GoogleAdsConfig) {\r\n  if (!config.refreshToken) {\r\n    throw new Error('Missing refresh token for Google Ads OAuth flow')\r\n  }\r\n\r\n  // Google Ads API requires customer ID without dashes\r\n  const customerId = config.customerId.replace(/-/g, '')\r\n  const loginCustomerId = config.loginCustomerId?.replace(/-/g, '') || customerId\r\n  \r\n  logger.info('Fetching Google Ads campaigns', { customerId, loginCustomerId })\r\n\r\n  const accessToken = await getGoogleAdsAccessToken(\r\n    config.clientId,\r\n    config.clientSecret,\r\n    config.refreshToken\r\n  )\r\n\r\n  // First, try to fetch directly from the provided customer ID\r\n  const directResult = await withRateLimit('google_ads', async () => {\r\n    return fetchCampaignsFromCustomer(customerId, accessToken, config.developerToken, loginCustomerId)\r\n  })\r\n\r\n  // If it's not a manager account and we got results, return them\r\n  if (!directResult.isManager && directResult.results?.length > 0) {\r\n    const resultCount = directResult.results.length\r\n    logAPISuccess('google_ads', 'fetchCampaigns', { resultCount, customerId })\r\n    return directResult\r\n  }\r\n\r\n  // If it's a manager account, we need to list client accounts and fetch from each\r\n  if (directResult.isManager) {\r\n    logger.info('Detected manager account, listing client accounts...')\r\n    \r\n    // Use the CustomerClient resource to get linked accounts (more reliable than listAccessibleCustomers)\r\n    let clientAccounts = await listClientAccounts(customerId, accessToken, config.developerToken)\r\n    \r\n    // Fallback to listAccessibleCustomers if no clients found\r\n    if (clientAccounts.length === 0) {\r\n      logger.info('No clients from CustomerClient, trying listAccessibleCustomers...')\r\n      const accessibleCustomers = await listAccessibleCustomers(accessToken, config.developerToken)\r\n      clientAccounts = accessibleCustomers\r\n        .filter(id => id !== customerId)\r\n        .map(id => ({ id, name: `Account ${id}` }))\r\n    }\r\n    \r\n    if (clientAccounts.length === 0) {\r\n      logger.warn('No client accounts found under manager account')\r\n      return { results: [], clientAccounts: [] }\r\n    }\r\n\r\n    logger.info(`Found ${clientAccounts.length} client accounts, fetching campaigns...`)\r\n\r\n    // Fetch campaigns from each client account\r\n    const allResults: any[] = []\r\n    \r\n    for (const client of clientAccounts) {\r\n      try {\r\n        const clientResult = await fetchCampaignsFromCustomer(\r\n          client.id, \r\n          accessToken, \r\n          config.developerToken,\r\n          loginCustomerId\r\n        )\r\n        \r\n        if (clientResult.results && !clientResult.isManager) {\r\n          // Add client ID and name to each result for tracking\r\n          const resultsWithClient = clientResult.results.map((r: any) => ({\r\n            ...r,\r\n            _clientCustomerId: client.id,\r\n            _clientCustomerName: client.name\r\n          }))\r\n          allResults.push(...resultsWithClient)\r\n          logger.info(`Fetched ${clientResult.results.length} campaign records from client ${client.id}`)\r\n        }\r\n      } catch (err: any) {\r\n        logger.warn(`Failed to fetch from client ${client.id}: ${err.message}`)\r\n      }\r\n    }\r\n\r\n    const resultCount = allResults.length\r\n    logAPISuccess('google_ads', 'fetchCampaigns', { resultCount, clientAccounts: clientAccounts.length })\r\n    \r\n    return { results: allResults, clientAccounts }\r\n  }\r\n\r\n  // No results found\r\n  logger.info('No Google Ads campaigns found')\r\n  return { results: [] }\r\n}\r\n\r\nexport function transformGoogleAdsData(apiData: any) {\r\n  const campaigns: any[] = []\r\n  const metrics: any[] = []\r\n\r\n  const campaignMap = new Map<string, any>()\r\n\r\n  const rows = Array.isArray(apiData?.results) ? apiData.results : []\r\n\r\n  rows.forEach((row: any) => {\r\n    const campaign = row?.campaign\r\n    if (!campaign?.id) {\r\n      return\r\n    }\r\n\r\n    const campaignId = campaign.id.toString()\r\n    const customerId = row?._clientCustomerId || null\r\n    const customerName = row?._clientCustomerName || null\r\n\r\n    if (!campaignMap.has(campaignId)) {\r\n      const budgetMicros = row?.campaignBudget?.amountMicros\r\n\r\n      campaignMap.set(campaignId, {\r\n        campaign_id: campaignId,\r\n        campaign_name: campaign.name,\r\n        platform: 'google_ads',\r\n        status: normalizeGoogleStatus(campaign.status),\r\n        budget_amount: budgetMicros ? Number(budgetMicros) / 1_000_000 : null,\r\n        customer_id: customerId,\r\n        customer_name: customerName,\r\n      })\r\n    }\r\n\r\n    const campaignMetrics = row?.metrics ?? {}\r\n    const segments = row?.segments ?? {}\r\n\r\n    metrics.push({\r\n      campaign_api_id: campaignId,\r\n      date: segments.date || new Date().toISOString().split('T')[0],\r\n      impressions: campaignMetrics.impressions ? Number(campaignMetrics.impressions) : 0,\r\n      clicks: campaignMetrics.clicks ? Number(campaignMetrics.clicks) : 0,\r\n      conversions: campaignMetrics.conversions ? Number(campaignMetrics.conversions) : 0,\r\n      spend: campaignMetrics.costMicros ? Number(campaignMetrics.costMicros) / 1_000_000 : 0,\r\n      revenue: campaignMetrics.conversionsValue\r\n        ? Number(campaignMetrics.conversionsValue)\r\n        : 0,\r\n    })\r\n  })\r\n\r\n  campaigns.push(...campaignMap.values())\r\n\r\n  // Extract unique customers from the client accounts\r\n  const customers = apiData?.clientAccounts || []\r\n\r\n  return { campaigns, metrics, customers }\r\n}\r\n\r\nfunction normalizeGoogleStatus(status: string): string {\r\n  const statusMap: Record<string, string> = {\r\n    'ENABLED': 'active',\r\n    'PAUSED': 'paused',\r\n    'REMOVED': 'archived',\r\n  }\r\n  return statusMap[status] || status.toLowerCase()\r\n}\r\n"],"names":[],"mappings":"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"}